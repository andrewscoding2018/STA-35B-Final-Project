---
title: "SidAndrewFinalProject"
author: "Andrew Kuang"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r}
library(tidyverse)
```


# Question 1. File Linkage Integrity

## a) Read the four CSV files into R, building four data frames with the names “Cases”, “Parents”, “Children” and “Payments”. Show the dimensions of these data frames. (You may find it useful to save these data frames as Rdata objects in a file using the save command. You can then recover them with the load command more quickly than reading the CSV file.)

```{r}

csvToDf = function(v) {
  return(as.data.frame(read.csv(v)))
  
}

cases <- csvToDf("cases.csv")
parents <- csvToDf("parents.csv")
children <- csvToDf("children.csv")
payments <- csvToDf("payments.csv")

```

## b) What is the distribution of the number of children attached to a case? Show an appropriate plot of the distribution, and mark the location of the average number in the plot.

```{r}

number <- children %>% select(CASE_NUM, ID) %>% group_by(CASE_NUM) %>% mutate(numberchildren = length(ID)) %>% ungroup(CASE_NUM) %>% summarize(mean(numberchildren))


children %>% select(CASE_NUM, ID)%>% group_by(CASE_NUM) %>% mutate(numberchildren = length(ID)) %>%
  ggplot(mapping = aes(x = numberchildren)) + geom_histogram(binwidth = 1) + geom_vline(xintercept = as.numeric(number), size = 5, color = "red")
  

```
## c) The file children.csv may have more than one record for each child. What is the largest number of cases associated with a child, and indicate why you believe that this is indeed the same child.

```{r}

children %>% select(ID, CASE_NUM) %>% group_by(ID) %>% mutate(childCaseCount = n()) %>% tally() %>% summarize(max(n))
```

This is the same child because we grouped by ID, which identifies the child. Timmy has 12 cases of child support, as a child needing support. 

## d) Does every absent parent (AP_ID) identified in the payments data have an identifying record in the parents data file?

```{r}
# Gets all the unique AP_IDs from the payments data file
payments_AP_ID <- payments %>% select(AP_ID) %>% arrange() %>% pull()
payments_AP_ID <- unique(payments_AP_ID)

# Gets all the unique AP_IDs from the payments data file
parents_AP_ID <- parents %>% select(AP_ID) %>% arrange() %>% pull()
parents_AP_ID <- unique(parents_AP_ID)

# Checks if AP_IDs are identical
identical(payments_AP_ID, parents_AP_ID)
```

# Question 2: Recoding Categories

Some categorical variables among these data frames are sparse (seldom observed). For example, the variable PYMNT_SRC in Payments has category ‘M’ with 2 cases and category ‘R’ with 7. These are too few for modeling in regression.

Write a function named “pool_categories” that recodes a categorical variable into a “simpler” factor with fewer categories by pooling categories with counts below a threshold into a category labeled ‘Other’ (a factor level which your function should check does not already exist!). You might find the R function %in% useful for this exercise.

```{r}

payments.short <- payments %>% slice(1:1000)

as.factor(payments.short$PYMNT_SRC)

pool_categories = function(variable, min){
  
  nameUse <- "Other";
  
  var.copy <- variable
  var_factor <- as.factor(var.copy)
  var_levels <- levels(var_factor)
  
  if(length(which(var_levels %in% "Other")) != 0)nameUse <- "Other1";
  
  levels(var_factor) <- c(levels(var_factor), nameUse)
  
  for(level in var_levels){
    if(sum(var.copy %in% level) < min){
      var.copy[which(variable == level)] <- nameUse
    }
  }
  return(as.factor(var.copy)) 
}

pool_categories(payments.short$PYMNT_SRC, 100)

```

# Question 3: Payment counts and amounts
## a) Make a variable Payments$DATE which is a viable R date by converting the COLLECTION_DT variable. Use this variable to find (i) the range of dates of all payments and (ii) the percentage of the total number of payments made before May 1, 2015.

```{r}
library(lubridate) # Aids in dealing with dates and times
```

```{r}
# Part i)
payments$DATE <- mdy_hms(payments$COLLECTION_DT) # Converts COLLECTION_DT to Date type and stores it in DATE column

range(payments$DATE) # Gets the range of dates

# Part ii)
payments_made <- payments %>% filter(DATE < as.Date("2015-05-01")) # Returns a df of payments made before 2015-05-01
perc_payments_made <- (nrow(payments_made) / length(payments$DATE)) * 100 # Percentage of payments made before 2015-05-01
perc_payments_made
```

## (b) Show a sequence plot of the total number of payments made on each day from May 1, 2015 through the end of the data.
```{r}
payments %>% group_by(DATE) %>% summarize(num_pymt = length(PYMNT_AMT)) %>% filter(DATE >= as.Date("2015-05-01")) %>% ggplot(mapping = aes(x = DATE, y = num_pymt)) + 
  geom_point()
```

## (c) What explains the bimodal shape of the marginal distribution of the number of payments over this time period? Explain with some evidence how you reached your opinion.

```{r}
payments %>% group_by(DATE) %>% summarize(num_pymt = length(PYMNT_AMT)) %>% filter(DATE >= as.Date("2015-05-01")) %>% ggplot(mapping = aes(x = num_pymt)) + 
  geom_density()
```

* There are two peaks in our data: one around 2.5k payments and one around 6k payments. The first peak is likely telling us that most days have this number of payments, whereas the second peak is the result of some kind of a special event


```{r}
payments %>% group_by(DATE) %>% summarize(num_pymt = length(PYMNT_AMT)) %>% filter(DATE >= as.Date("2015-05-01"), num_pymt > 2000 & num_pymt < 3000) %>% ggplot(mapping = aes(x = month(DATE), y = num_pymt)) + 
  geom_point()
```


## (d) Describe the distribution of the payment amounts. Do you have an explanation for its shape? (You
might find it useful to work with a sample for plotting. R takes a while to draw 1.5 million points.)

First, let's graph the distribution with a sample of 100,000 points:

```{r}
sample_n(payments, 100000) %>% ggplot(mapping = aes(x = log(PYMNT_AMT))) + geom_density()
```
We can see that payment amount is far less before 2015. Furthermore, we can also see that there is only one "level" of payment before 2015, whereas after we can see that there are several different levels of payment.


```{r}
inner_join(children, payments, by = "CASE_NUM") %>% select(CASE_NUM, ID, PYMNT_AMT, DATE) %>% filter(DATE >= as.Date("2015-01-01")) %>% group_by(DATE) %>% summarize(num_child = length(PYMNT_AMT))
```

# Question 4: Payments for Cases

The unit of analysis for this question is the payment behavior of an absent parent. Hence, if the parent is involved in several cases, you will need to accumulate the relevant information. You may find it useful for this and the next question to build a data frame for parents that collects the relevant information for each parent. You may find dplyr useful here and elsewhere, but you don’t have to use it.

## (a) It has been conjectured that parents deemed responsible for more children are more likely to make either a larger number of payments or a larger total payment amount over this period. Is that true?

* First, we join the children and payments data sets in order to find the number of children per absent parent
  + We also summarize the number of payments made, as well as the sum of these payments to see if there is any correlation between number of children and number of payments / total payment amount
    
```{r}
# First, join the data frames
joined_frame <- left_join(parents, payments, by = "AP_ID") %>% full_join(children, by = "CASE_NUM")

# Creates a data frame with number of children, number of payments, and total payment amount
children_and_pymnts <- joined_frame %>% group_by(AP_ID) %>% 
  summarize(num_child = length(unique(ID)), num_pymnt = length(PYMNT_AMT), total_pymnt = sum(PYMNT_AMT))
```

* Next, we check if there are any NA values for us to convert to 0:

```{r}
children_and_pymnts %>% filter(is.na(total_pymnt))
```


```{r}
children_and_pymnts %>% filter(is.na(AP_ID)) # Finds NA row

children_and_pymnts["total_pymnt"][is.na(children_and_pymnts["total_pymnt"])] <- 0 # Convert NA payments to $0 (these are the parents who didn't pay, so they were in the parents data set but not the payments one)

children_and_pymnts <- na.omit(children_and_pymnts) # Omit any remaining NA values

length(parents$AP_ID) == nrow(children_and_pymnts) # Check that we have the same number of AP_IDs across the board
```

* We want to test whether "parents deemed responsible for more children are more likely to make either a larger number of payments or a larger total payment amount over this period"
  + For this, we can compare the correlations of "number of children vs number of payments" and "number of children vs total payments"

```{r}
cor(children_and_pymnts$num_child, children_and_pymnts$num_pymnt) # Number of children vs number of payments
cor(children_and_pymnts$num_child, children_and_pymnts$total_pymnt) # Number of children vs total payments
```

* We can see from the respective Pearson Correlation Coefficients that parents deemed responsible for more children are more likely to make a larger total payment over the time period rather than make more payments (if only by a little bit)

## (b) It has been conjectured that parents responsible for younger children are more likely to make more payments. Is the average age of the children of an absent parent associated with the total amount of payments made by the absent parent? (Define a child’s age as the age on Jan 1, 2017.))

```{r}
DOB_fixed <- mdy_hms(joined_frame$DATE_OF_BIRTH_DT) # fix the DATE-OF_BIRTH_DT variable so we are now working with Date objects

# Here we are creating a data frame that includes the mean age of the children for each absent parent
children_and_payments2 <- joined_frame %>% mutate(
  age = 2017 - (year(DOB_fixed) + (month(DOB_fixed) / 12) + (day(DOB_fixed) / 365))) %>%
  group_by(AP_ID) %>% 
  summarize(num_child = length(unique(ID)), 
    total_pymnt = sum(PYMNT_AMT), 
    mean_age = mean(age))
```

```{r}
# Omit any NA values
children_and_payments2 <- na.omit(children_and_payments2)

# Preview 
head(children_and_payments2)
```

* We now look at the correlation between mean age and the number of payments made using the Pearson Correlation Coefficient

```{r}
cor(children_and_payments2$mean_age, children_and_payments2$total_pymnt)
```

The Pearson Correlation Coefficient appears to be very small; therefore, there isn't a strong correlation between the mean age of the children and the number of payments made

## (c) Does the location of the parent (AP_ADDR_ZIP) anticipate the total amount of payments made by the absent parent?

* We can answer this question using an ANOVA test. We set up the following hypothesis test with a confidence level of 95%:
  + Step 1: make assumptions and state null and alternate hypotheses
    - Assumption 1: we assume that the samples are independent
    - Assumption 2: we assume the response variable is approximately normally distributed for each category
    - Assumption 3: we assume that the population variances are equal across responses for each category
    - H0: the means of the total amount in payments are the same across all groups
    - Ha: the means of the total amount in payments are *not* the same across all groups
    
```{r}
# Visualization
temp_df <- left_join(children_and_pymnts, parents, by = "AP_ID") %>% select(AP_ID, num_child, total_pymnt, AP_ADDR_ZIP)
boxplot(total_pymnt ~ AP_ADDR_ZIP, data = temp_df)
```

All the means looks roughly the same, so we can proceed

*See if we actually have to prove assumptions!!*
```{r}
left_join(children_and_pymnts, parents, by = "AP_ID") %>% select(AP_ID, num_child, total_pymnt, AP_ADDR_ZIP) %>% 
  ggplot(mapping = aes(log(total_pymnt))) + geom_density() + facet_grid(~AP_ADDR_ZIP)
```

  + Step 2/3: find F-statistic and p-value
```{r}
model <- aov(children_and_pymnts$total_pymnt ~ parents$AP_ADDR_ZIP)
summary(model)
```
  + Step 4: make a decision
    - Since the p-value is smaller than 0.05, we reject H0
    
  + Step 5: state a conclusion
    - Since the p-value is smaller than 0.05, we reject the null hypothesis that the means are equal across all categories
    
## (d) Does the combination of attributes of the parent with the number and average age of the children involved predict the total amount of payments made by a parent? Explain your results briefly. (Note: It makes no sense to remove cases with missing values of a categorical variable. Missingness just defines another category of the variable.)

# Question 5: Consistency

Again, the unit of analysis for this question is an absent parent. An important aspect of payments is the consistency of the payments over time. A steady income stream is, for many, preferable to a highly volatile, unpredictable payment schedule, even if the latter has a higher average.

Hints:
* Absent parent --> the aggregated data for analyssi should have one parent in one row
* Use payments data to calculate totla daily payment for each day of each parent, totla number of payments, mean and SD of total daily payments, cv
* Divide the data into 3 groups for low, median,and high CV. You should describe your criteria

## (a) Among all parents who made payments, is there any association between the SD of total daily payments and the average of total daily payments?

```{r}

payment_Summary <- payments %>% na.omit() %>% group_by(DATE, AP_ID) %>% select(PYMNT_AMT) %>% summarize(totalDailySum = sum(PYMNT_AMT))

summarySD <- payment_Summary %>% group_by(DATE) %>% filter(n() > 1) %>% summarize(sd = sd(totalDailySum, na.rm = TRUE), mean = mean(totalDailySum, na.rm = TRUE))

summarySD %>% summarize(cor = cor(sd, mean))
```

## (b) The coefficient of variation (CV) is the ratio of the SD of daily payments to the mean. Show time sequence plots of the payments of 3 parents, with low, medium and high CV. That is, find three representative parents who make payments. One of these three should have a high CV, another an medium CV, and a third a low CV.

```{r}

summarySD %>% mutate(cv = sd/mean) %>% mutate(level = ifelse(cv < 0.7, "low", ifelse(cv < 1.4, "medium", ifelse(cv<10000, "high")))) %>% ggplot(mapping = aes(x = DATE, y = cv)) +
  geom_point() +
  geom_line() +
  facet_wrap(~level)


```


## (c) Is the CV of payments associated with the total amount of payments over this time period?

```{r}

summarySD <- payment_Summary %>% group_by(DATE) %>% filter(n() > 1) %>% summarize(sd = sd(totalDailySum, na.rm = TRUE), mean = mean(totalDailySum, na.rm = TRUE), n = n())
summarySD %>% mutate(cv = sd/mean) %>% summarize(cor = cor(cv, n))
payment_Summary
```

## (d) (Bonus Question) Do any attributes of the parent as revealed in these data anticipate that the parent will make consistent payments, that is, have small CV?






